# -*- coding: utf-8 -*-
"""Cópia de TrabalhoIA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V4hZvVErZUgOv75SHhHcFtJfXXkes7_e

# **Importando pacotes**
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split # for split the dataset for training and testing
from sklearn.tree import DecisionTreeClassifier # for using Decision Tree Algoithm
from sklearn import metrics #for checking the model accuracy

from matplotlib import pyplot as plt
from sklearn import tree
from sklearn.tree import plot_tree

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import f1_score,confusion_matrix
from sklearn.metrics import accuracy_score

from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2

from sklearn.tree import export_text

"""# **Importando dados do CSV**"""

url = 'https://raw.githubusercontent.com/joaooliveira10/IA/main/TrabalhoIA/songs_normalize.csv'
df = pd.read_csv(url)
df.info()
# Dataset is now stored in a Pandas Dataframe

df.describe()

"""# **Pré-processamento**

Alterando a coluna de duração, que está em milisegundos, para segundos.
"""

df["duration"] = df.duration_ms.apply(lambda x : round(x/1000))
df.drop("duration_ms", axis='columns', inplace=True)

df.head()

"""Vamos dar uma olhada na distribuição do atributo 'popularity'."""

ax = plt.subplots(figsize=(20, 12))
ax = sns.countplot(x=df['popularity'])

"""Como podemos ver no gráfico, a distribuição da popularidade não está muito bem feita. Por conta disso, vamos remover as músicas que possuem popularidade menor que 45. Com isso, ficaremos com 1758 músicas."""

df = df[df.popularity >= 45]

df.info()

"""Nova distribuição:"""

ax = plt.subplots(figsize=(20, 12))
ax = sns.countplot(x=df['popularity'])

"""Vamos adicionar uma coluna chamada 'popularity_class', baseada na popularidade da música, que será usada para classificar a base."""

corte = 68
# condições da coluna de classificação
conditions = [
    (df['popularity'] >= 45) & (df['popularity'] < corte),
#     (df['popularity'] >= 57) & (df['popularity'] < 67),
    (df['popularity'] >= corte) & (df['popularity'] < 90),
#     (df['popularity'] >= 75) & (df['popularity'] < 90),
    ]

# valores da coluna de classificação
# classes = ['0', '1', '2', '3']
classes = ['boa', 'sucesso']

# criando a coluna de classificação
df['popularity_class'] = np.select(conditions, classes)

# resultado
df

"""Removendo as colunas que não serão usadas para classificar."""

y = df.popularity_class
removed_features = ['artist', 'song', 'popularity', 'genre', 'popularity_class', 'instrumentalness']
x = df.drop(removed_features, axis = 1)

# resultado
x.head()

"""Features que usaremos."""

features = x.columns

print(features)

"""Visualizando a distribuição da popularity_class"""

ax = sns.countplot(x = y)

"""correlation map - podemos ver que não há nenhum atributo correlacionado então nao precisamos remover nenhum"""

f, ax = plt.subplots(figsize=(14, 14))
sns.heatmap(x.corr(), annot=True, linewidths=.5, fmt= '.1f', ax=ax)

"""# **Metodologia**"""

# dividindo a base em treino e teste (70-30)
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)

print(x_train.shape)
print(x_test.shape)

# random forest
clf_rf = RandomForestClassifier(random_state=43)
clr_rf = clf_rf.fit(x_train, y_train)
rf_prediction = clf_rf.predict(x_test)

# accuracy
rf_ac = accuracy_score(y_test, rf_prediction)
print('Precisão do Random Forest: ', rf_ac)

# matriz de confusão
rf_cm = confusion_matrix(y_test, rf_prediction)
sns.heatmap(rf_cm, annot=True, fmt="d")

"""# **Árvore de Decisão**"""

# selecionando uma das árvores do random forest
estimator = clf_rf.estimators_[5]

plt.figure(figsize=(30, 20))
plot_tree(estimator, max_depth=3, feature_names=features, class_names=classes, filled=True)
plt.title("Árvore de Decisão")
plt.show()

tree_rules = export_text(estimator, feature_names=list(features), max_depth=7, show_weights=True)
print(tree_rules)